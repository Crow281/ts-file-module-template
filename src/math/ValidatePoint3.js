/* eslint-disable */
// @ts-nocheck
/**
 * Some of the scripts creating generated scripts are
 * dependant on 3rd party libraries.
 * These 3rd party libraries sometimes generate code
 * that would cause errors, like creating unused variables.
 * While said errors would not cause compilation problems,
 * it does disrupt strict error checks.
 * For this unfortunate reason, eslint-disable and ts-nocheck
 * are at the top of the file, to tell eslint and
 * the TypeScript compiler not to run any error checks.
 *
 * This file was dynamically generated via script.
 * Generated files should NOT be edited by hand.
 * If you need to change something,
 * edit the script that created this file
 * or the file that it generated this script from.
 * The generation scripts are located inside of
 * {project}/config/generate/*.
 *
 * Any UTF-8 file that starts exactly with
 * directive eslint-disable, directive ts-nocheck,
 * and this comment block, character by character,
 * will be considered a generated file.
 * Files with these exact comments will be deleted if you use:
 * npm run clean:generated
 */
//This file was generated by script:
//config/generate/json-schema/GenerateSchemaValidators.ts
/**
 *
 * Copyright (c) 2025 Crow281
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
/**
 * HACK: Note that the generation script is basically interfering
 * with how AJV generates code and as such,
 * may need to be updated at some point.
 *
 * Basically, I am forcibly inserting the validation
 * function's JSDoc.
 * Attempts to use .d.ts files resulted in TypeDoc
 * mistaking it for a separate module.
 * Ideally, if such a thing is possible,
 * someone more familiar with TypeDoc than me should
 * figure out how to separate the JSDoc into a separate
 * file instead of forcibly inserting it into the
 * originally generated module.
 */
"use strict";
//Import the type being validated into JSDoc.
//Use an alias, SchemaInterface, to make name collision unlikely.
/** @import { type Point3 as SchemaInterface } from "./Point3" */

/**
 * @typedef {Object} DataValidationCxt
 * Interface for an object being used to configure the validation function.
 * @property {string} [instancePath = ""]
 * Path to the specific location of the JSON data being validated.
 *
 * Is used to to tell error objects the location
 * of the error if validation fails.
 * @property {{ [K in (string | number)]: any }} parentData
 * The parent object of the current data being validated.
 * @property {(string | number)} parentDataProperty
 * Name of the property in parentData being validated.
 * @property {Record<string, any> | any[]} [rootData]
 * The original, unmodified object passed to the validation function.
 *
 * If the dataCtx parameter passed to the validation function
 * is left empty, this will be set to parameter data.
 */

/**
 * @typedef {Object} ErrorObject
 * Reports one of the reasons JSON Schema validation failed.
 *
 * This interface is equivalent to ajv's
 * {@link https://ajv.js.org/api.html#error-objects ErrorObject}.
 * @property {string} keyword
 * Validation keyword.
 * @property {string} instancePath
 * JSON Pointer to the location in the data instance (e.g. "/prop/1/subProp").
 * @property {string} schemaPath
 * JSON Pointer to the location of the failing keyword in the schema.
 * @property {object} params
 * Object with additional information about error.
 * It can be used to generate custom error messages,
 * for example, in conjunction with the ajv-i18n package.
 *
 * See {@link https://ajv.js.org/api.html#error-parameters error parameters}
 * for more details.
 * @property {string} [propertyName]
 * If error represented a "propertyNames" error,
 * this is set to the propertyName that had the error.
 * @property {string} [message]
 * The error message.
 * @property {any} [schema]
 * The value of the failing keyword in the schema.
 * @property {object} [parentSchema]
 * The object containing the keyword.
 * @property {any} [data]
 * The data validated by the keyword.
 */

/**
 * @function
 */
export const validatePoint3 = validate10;
const schema11 = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "urn:module:math/geometry/Point3.schema.json",
    title: "Point3",
    description: "Represents a 3d coordinate in space.",
    type: "object",
    properties: {
        x: {
            description: "X coordinate of the position.",
            type: "number",
            default: 0,
        },
        y: {
            description: "Y coordinate of the position.",
            type: "number",
            default: 0,
        },
        z: {
            description: "Z coordinate of the position.",
            type: "number",
            default: 0,
        },
    },
    required: ["x", "y", "z"],
    additionalProperties: false,
};

/**
 * Checks whether a given value is a valid instance of
 * {@link SchemaInterface Point3} and matches its
 * {@link https://json-schema.org/ JSON Schema}.
 * @param {any} data
 * Object we want to check to see if it matches {@link SchemaInterface Point3}.
 * @param {DataValidationCxt} [dataCtx]
 * Used to configure the validation function.
 * @returns {data is SchemaInterface}
 * true if data is confirmed to be a valid instance of
 * type {@link SchemaInterface Point3}, false otherwise.
 *
 * If result is false, you may check property {@link validatePoint3#errors}
 * for an array of {@link ErrorObject}s to check whatever went wrong.
 * @example
 * This example shows you how you can verify that a
 * value matches type Point3.
 * ```ts
 * //A function that can only operate on Point3.
 * //Will print it to the console.
 * function printObject(obj: Point3): void {
 *     console.log(obj);
 * }
 *
 * //Some object we want to validate.
 * const obj: unknown = {
 *     someProperty: 25
 * };
 *
 * //If this object is a valid instance of Date.
 * if (validatePoint3(obj)) {
 *     //We can use it as the type.
 *     printObject(obj);
 * }
 * ```
 */
function validate10(
    data,
    { instancePath = "", parentData, parentDataProperty, rootData = data } = {},
) {
    /*# sourceURL="urn:module:math/geometry/Point3.schema.json" */ let vErrors =
        null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.x === undefined) {
            const err0 = {
                instancePath,
                schemaPath: "#/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
            };
            if (vErrors === null) {
                vErrors = [err0];
            } else {
                vErrors.push(err0);
            }
            errors++;
        }
        if (data.y === undefined) {
            const err1 = {
                instancePath,
                schemaPath: "#/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
            };
            if (vErrors === null) {
                vErrors = [err1];
            } else {
                vErrors.push(err1);
            }
            errors++;
        }
        if (data.z === undefined) {
            const err2 = {
                instancePath,
                schemaPath: "#/required",
                keyword: "required",
                params: { missingProperty: "z" },
                message: "must have required property '" + "z" + "'",
            };
            if (vErrors === null) {
                vErrors = [err2];
            } else {
                vErrors.push(err2);
            }
            errors++;
        }
        for (const key0 in data) {
            if (!(key0 === "x" || key0 === "y" || key0 === "z")) {
                const err3 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: { additionalProperty: key0 },
                    message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                    vErrors = [err3];
                } else {
                    vErrors.push(err3);
                }
                errors++;
            }
        }
        if (data.x !== undefined) {
            let data0 = data.x;
            if (!(typeof data0 == "number" && isFinite(data0))) {
                const err4 = {
                    instancePath: instancePath + "/x",
                    schemaPath: "#/properties/x/type",
                    keyword: "type",
                    params: { type: "number" },
                    message: "must be number",
                };
                if (vErrors === null) {
                    vErrors = [err4];
                } else {
                    vErrors.push(err4);
                }
                errors++;
            }
        }
        if (data.y !== undefined) {
            let data1 = data.y;
            if (!(typeof data1 == "number" && isFinite(data1))) {
                const err5 = {
                    instancePath: instancePath + "/y",
                    schemaPath: "#/properties/y/type",
                    keyword: "type",
                    params: { type: "number" },
                    message: "must be number",
                };
                if (vErrors === null) {
                    vErrors = [err5];
                } else {
                    vErrors.push(err5);
                }
                errors++;
            }
        }
        if (data.z !== undefined) {
            let data2 = data.z;
            if (!(typeof data2 == "number" && isFinite(data2))) {
                const err6 = {
                    instancePath: instancePath + "/z",
                    schemaPath: "#/properties/z/type",
                    keyword: "type",
                    params: { type: "number" },
                    message: "must be number",
                };
                if (vErrors === null) {
                    vErrors = [err6];
                } else {
                    vErrors.push(err6);
                }
                errors++;
            }
        }
    } else {
        const err7 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: { type: "object" },
            message: "must be object",
        };
        if (vErrors === null) {
            vErrors = [err7];
        } else {
            vErrors.push(err7);
        }
        errors++;
    }
    validate10.errors = vErrors;
    return errors === 0;
}

/**
 * If the validation function returns false,
 * this property will be set to an array of {@link ErrorObject}s,
 * explaining why validation failed.
 * @property
 * @type {null | ErrorObject[]}
 * @example
 * This example shows you how to fetch the resulting
 * {@link ErrorObject}
 * array if something goes wrong during validation.
 * ```ts
 * //Some object we want to validate.
 * const obj: unknown = {
 *     someProperty: 25
 * };
 *
 * //If this object is NOT a valid instance of Date.
 * if (!validatePoint3(obj)) {
 *     //Tell user validation failed.
 *     console.log("Obj is NOT an instance of Date");
 *
 *     //Fetch the list of errors.
 *     //errors is a simplified, standalone equivalent to ErrorObject[]
 *     //from the AJV library.
 *     const errors = validatePoint3.errors;
 *
 *     //Iterate the errors.
 *     for (const error of errors) {
 *         //Print the error representing whatever went wrong.
 *         console.log(error);
 *     }
 * }
 * ```
 */
validate10.errors = null;
