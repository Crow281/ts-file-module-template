/**
 * Some of the scripts creating generated scripts are
 * dependant on 3rd party libraries.
 *
 * This file was dynamically generated via script.
 * Generated files should NOT be edited by hand.
 * If you need to change something,
 * edit the script that created this file
 * or the file that it generated this script from.
 * A comment showing the path to said script should
 * be just below this one.
 * The generation scripts in general are located inside of
 * {project}/config/generate/*.
 *
 * Any UTF-8 file that contains this comment block,
 * character by character, will be considered a generated file.
 * Files with these exact comments will be deleted if you use:
 * npm run clean:generated
 */
//This file was generated by script:
//config/generate/json-schema/validators/GenerateValidatorDefinition.ts
//Import the type being validated.
//Use an alias, SchemaInterface, to make sure there is no name collision.
import { Circle as SchemaInterface } from "./Circle";
//We need to temporarily disable es-lint right here,
//because having an error here really is optional.
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore -- Import the true ErrorObject interface if AJV is available and do nothing if it isn't.
import type { ErrorObject as AjvErrorObject } from "ajv";

/**
 * Reports one of the reasons JSON Schema validation failed.
 *
 * This interface is a self-contained equivalent to ajv's
 * {@link https://ajv.js.org/api.html#error-objects ErrorObject}
 * and is used if the AJV library isn't available.
 * @typeParam K
 * Type of the object identifying the error.
 * @typeParam P
 * Type of the params property, containing data about the error.
 * @typeParam S
 * Type of the schema property, which if set,
 * has a reference to the original schema object.
 */
interface StandaloneErrorObject<
    K extends string = string,
    P = Record<string, unknown>,
    S = unknown,
> {
    /**
     * Validation keyword.
     */
    keyword: K;

    /**
     * JSON Pointer to the location in the data instance (e.g. "/prop/1/subProp").
     */
    instancePath: string;

    /**
     * JSON Pointer to the location of the failing keyword in the schema.
     */
    schemaPath: string;

    /**
     * Object with additional information about error.
     * It can be used to generate custom error messages,
     * for example, in conjunction with the ajv-i18n package.
     *
     * See {@link https://ajv.js.org/api.html#error-parameters error parameters}
     * for more details.
     */
    params: P;

    /**
     * If error represented a "propertyNames" error,
     * this is set to the propertyName that had the error.
     */
    propertyName?: string;

    /**
     * The error message.
     */
    message?: string;

    /**
     * The value of the failing keyword in the schema.
     *
     * Contains the original schema that triggered the error.
     */
    schema?: S;

    /**
     * The object containing the keyword.
     */
    parentSchema?: Record<string, unknown>;

    /**
     * The data validated by the keyword.
     */
    data?: unknown;
}

/**
 * Defines the type of the objects used to report errors.
 * Uses the original AJV definition if available and a standalone definition if not.
 */
type ErrorObject = unknown extends AjvErrorObject
    ? StandaloneErrorObject
    : AjvErrorObject;

/**
 * @function
 * Checks whether a given value is a valid instance of
 * {@link SchemaInterface Circle} and matches its
 * {@link https://json-schema.org/ JSON Schema}.
 * @param {any} data
 * Value we want to check to see if it matches {@link SchemaInterface Circle}.
 * @returns {data is SchemaInterface}
 * true if data is confirmed to be a valid instance of
 * type {@link SchemaInterface Circle}, false otherwise.
 *
 * If result is false, you may check property {@link validateCircle#errors}
 * for an array of {@link ErrorObject}s to figure out whatever went wrong.
 * @example
 * This example shows you how you can verify that a
 * value matches type Circle.
 * ```TypeScript
 * //A function that can only operate on Circle.
 * //Will print it to the console.
 * function printObject(obj: Circle): void {
 *     console.log(obj);
 * }
 *
 * //Some object we want to validate.
 * const obj: unknown = {
 *     someProperty: 25
 * };
 *
 * //If this object is a valid instance of Circle.
 * if (validateCircle(obj)) {
 *     //We can use it as the type.
 *     printObject(obj);
 * }
 * ```
 */
declare const validateCircle: {
    (data: unknown): data is SchemaInterface;

    /**
     * If the validation function returns false,
     * this property will be set to an array of {@link ErrorObject}s,
     * explaining why validation failed.
     *
     * If your project contains
     * {@link https://www.npmjs.com/package/ajv package ajv},
     * then
     * this function will use
     * {@link https://ajv.js.org/api.html#error-objects AJV's interface}
     * for them.
     * If not, it will use an internal and independant interface,
     * {@link StandaloneErrorObject},
     * to define them. Note that there is no runtime difference
     * between the two types.
     * @example
     * This example shows you how to fetch the resulting
     * {@link ErrorObject}
     * array if something goes wrong during validation.
     * ```TypeScript
     * //Some object we want to validate.
     * const obj: unknown = {
     *     someProperty: 25
     * };
     *
     * //If this object is NOT a valid instance of Circle.
     * if (!validateCircle(obj)) {
     *     //Tell user validation failed.
     *     console.log("Obj is NOT an instance of Circle");
     *
     *     //Fetch the list of errors.
     *     const errors = validateCircle.errors;
     * 
     *     //By default, the error messages are in English.
     *     //Use ajv-i18n to localize the error messages.
     *     //This localize function was imported from "ajv-i18n/localize/fr"
     *     //and will translate the error messages to French.
     *     localize(errors);
     *
     *     //Iterate the errors.
     *     for (const error of errors) {
     *         //Print the error representing whatever went wrong.
     *         console.log(error);
     *     }
     * }
     * ```
     */
    errors?: null | ErrorObject[];
};
