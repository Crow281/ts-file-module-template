/*
 * The MIT License
 *
 * Copyright 2025 Crow281.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
import { dirname, relative } from "node:path";

/**
 * Represents an imported object.
 */
export class ImportReflection {
    /**
     *
     * @param importReflections
     * Collection of imports we want to convert to code.
     * @param importingModule
     * The module importing these modules.
     * If used, it will make the import path relative to it.
     * @returns
     * TypeScript code for making all the desired imports.
     */
    public static toCode(
        importReflections: Iterable<ImportReflection>,
        importingModule?: string,
    ): string {
        //List of code generated by imports.
        let importCode: string[] = [];

        //Iterate the imports.
        for (const importReflection of importReflections) {
            //We don't need to import the importing module into itself.
            if (importReflection.module === importingModule) {
                continue;
            }

            //Convert the module import to code.
            const code: string = importReflection.toCode(importingModule);

            //Save to list of imports.
            importCode.push(code);
        }

        //Combine the code and return it.
        return importCode.join("\n");
    }

    /**
     * Module being imported from.
     */
    _module: string;

    /**
     * Declaration from the module being imported.
     */
    _declarationName: string;

    /**
     * true if this is the default import of the module,
     * false otherwise.
     */
    _isDefault: boolean;

    /**
     * true if this is importing a type,
     * false if it is importing a variable.
     */
    _isType: boolean;

    /**
     * The alias chosen for this import.
     */
    _aliasName: string;

    /**
     *
     */
    constructor(
        module: string,
        declarationName: string,
        isType: boolean,
        isDefault: boolean,
        aliasName?: string,
    ) {
        //Save params.
        this._module = module;
        this._declarationName = declarationName;
        this._isType = isType;
        this._isDefault = isDefault;

        //If an alias is being used.
        if (aliasName) {
            //Store the alias.
            this._aliasName = aliasName;

            //If no alias.
        } else {
            //Use the original type name.
            this._aliasName = declarationName;
        }
    }

    /**
     * @returns
     * Path used to import the module.
     */
    public get module(): string {
        return this._module;
    }

    /**
     * @returns
     * Declaration from the module being imported.
     */
    public get declarationName(): string {
        return this._declarationName;
    }

    /**
     * @returns
     * true if this is importing a type,
     * false if it is importing a variable.
     */
    public get isType(): boolean {
        return this._isType;
    }

    /**
     * @returns
     * true if this is the default import,
     * false otherwise.
     */
    public get isDefault(): boolean {
        return this._isDefault;
    }

    /**
     * @returns
     * The alias chosen for this import.
     * If typeName was unique, this will
     * be the same as typeName.
     */
    public get aliasName(): string {
        return this._aliasName;
    }

    /**
     * @param importingModule
     * The module importing this module.
     * If used, it will make the import path relative to it.
     * @returns
     * The import in its code representation.
     */
    public toCode(importingModule?: string): string {
        //Fetch variables we need.
        const relativeModule: string = this.relativeModule(importingModule);
        const declarationName: string = this._declarationName;
        const aliasName: string | undefined = this._aliasName;

        //Code we should insert if this is a type.
        let typeInsert: string;

        //If this is a type.
        if (this._isType) {
            //Insert keyword to indicate this is a type.
            typeInsert = "type ";

            //If this is a variable.
        } else {
            //Don't insert anything.
            typeInsert = "";
        }

        //Contains the declaration we are importing.
        //Allows us to insert simply the declaration itself
        //or its alias if it needs one.
        let declarationInsert: string;

        //If we have a custom alias.
        if (declarationName !== aliasName) {
            //Create an alias from the declaration.
            declarationInsert = `${typeInsert}${declarationName} as ${aliasName}`;

            //If we do NOT have a custom alias.
        } else {
            //Then just directly use the original declaration.
            declarationInsert = `${typeInsert}${aliasName}`;
        }

        //If this is a default import.
        if (this._isDefault) {
            //Then don't surround the declaration in braces.
            return `import ${declarationInsert} from "${relativeModule}";`;

            //If this is a non-default import.
        } else {
            //Surround the import in braces.
            return `import { ${declarationInsert} } from "${relativeModule}";`;
        }
    }

    /**
     * @param importingModule
     * The module importing this module.
     * If used, it will make the import path relative to it.
     * @returns
     * Correct import path to use.
     */
    private relativeModule(importingModule?: string): string {
        //Fetch parameters we need.
        const module = this._module;

        //If we were given an importingModule.
        if (importingModule) {
            //Fetch folder the importing module is in.
            const importingModuleDir: string = dirname(importingModule);

            //Fetch folder the imported module is in.
            const moduleDir: string = dirname(module);

            //Calculate the relative module path.
            let relativeModule: string = relative(importingModuleDir, module);

            //If the importing and imported module are in the same dir.
            if (importingModuleDir === moduleDir) {
                //Append "./" to indicate that it is in the same folder.
                relativeModule = "./" + relativeModule;
            }

            return relativeModule;

            //If there is no importingModule.
        } else {
            //Then just use the original absolute path.
            return module;
        }
    }
}

/**
 * Records the list of imports a given file has made.
 * If multiple types with the same name are requested,
 * it will create an alias for them.
 */
export class ImportFactory {
    /**
     * Array of all imports created so far.
     */
    private readonly _imports: ImportReflection[] = [];

    /**
     * Maps aliases being used to their imports.
     */
    private readonly _aliasToImport: Map<string, ImportReflection> = new Map();

    /**
     * Maps modules to declarations being imported
     * from them to their Import object.
     */
    private readonly _moduleToDeclarationToImport: Map<
        string,
        Map<string, ImportReflection>
    > = new Map();

    /**
     *
     */
    constructor() {
        //
    }

    /**
     *
     * @param module
     * Module we are importing a type from.
     * @param declarationName
     * Name of the declaration we want to import from module.
     * @returns
     * Object representing the import.
     */
    public import(
        module: string,
        declarationName: string,
        isType: boolean = true,
        isDefault: boolean = false,
    ): ImportReflection {
        //Fetch properties we need.
        const moduleToDeclarationToImport = this._moduleToDeclarationToImport;

        //Fetch the mapping of types in this module to
        //the imports representing them.
        let declarationToImport: Map<string, ImportReflection> | undefined =
            moduleToDeclarationToImport.get(module);

        //If this module has been imported before
        //and therefore has an entry in moduleToTypeToImport.
        if (declarationToImport) {
            //Attempt to fetch the import for this typeName.
            let importReflection: ImportReflection | undefined =
                declarationToImport.get(declarationName);

            //If import exists.
            if (importReflection) {
                //Just return the one that already exists.
                return importReflection;

                //If import does not exist.
            } else {
                //Create, store, and return import.
                return this.createImport(
                    declarationToImport,
                    module,
                    declarationName,
                    isType,
                    isDefault,
                );
            }

            //If this module has never been used before.
        } else {
            //Create new map for this module.
            declarationToImport = new Map();

            //Store the module's map for future use.
            moduleToDeclarationToImport.set(module, declarationToImport);

            //Create, store, and return import.
            return this.createImport(
                declarationToImport,
                module,
                declarationName,
                isType,
                isDefault,
            );
        }
    }

    /**
     *
     * @param module
     * Module we are importing a type from.
     * @param declarationName
     * Name of the declaration we want to import from module.
     * @param typeToImport
     * Module's map, mapping the types within to their import reflections.
     *
     * The newly created import will be stored to it.
     * @param isType
     * true if you are importing a type, false if you are importing a variable.
     * @param isDefault
     * true if this is a default import, false otherwise.
     * @returns
     * The newly created import reflection.
     */
    private createImport(
        typeToImport: Map<string, ImportReflection>,
        module: string,
        declarationName: string,
        isType: boolean,
        isDefault: boolean = false,
    ): ImportReflection {
        //Fetch properties we need.
        const imports = this._imports;
        const aliasToImport = this._aliasToImport;

        //Pick an alias.
        const alias: string = this.createAlias(declarationName);

        //Create import object.
        const importReflection = new ImportReflection(
            module,
            declarationName,
            isType,
            isDefault,
            alias,
        );

        //Store it to the array of all imports.
        imports.push(importReflection);

        //Store it to the mapping of aliases to imports.
        aliasToImport.set(alias, importReflection);

        //Store it to the mapping of modules.
        typeToImport.set(declarationName, importReflection);

        return importReflection;
    }

    /**
     *
     * @param declarationName
     * Declaration we want an alias for.
     * @returns
     * Will return the original value of declarationName
     * if it isn't already being used.
     * If it is, it will select an unused alias by appending some number to it.
     */
    private createAlias(declarationName: string): string {
        //Fetch alias map so that we can check what has already been used.
        const aliasToImport = this._aliasToImport;

        //Alias that will be used for interface in code.
        let aliasName: string;

        //The next alias number we will try.
        //For example, if "DeclarationName1" is taken,
        //we can try "DeclarationName2" next.
        let nextAliasNumber: number = 0;

        //Keep checking possible aliases until we find an unused one.
        for (
            //Use the original typeName if possible.
            //We will need to use an alias if not.
            aliasName = declarationName;
            //Keep iterating until we find an alias that isn't being used.
            aliasToImport.has(aliasName);
            //Update the alias we are trying.
            aliasName = declarationName + nextAliasNumber
        ) {
            //If we reached this point, the previous aliasName didn't work,
            //so update the next alias number to try.
            nextAliasNumber += 1;
        }

        return aliasName;
    }

    /**
     *
     * @returns
     * Import code for all imports created with this factory.
     */
    public toCode(importingModule?: string): string {
        return ImportReflection.toCode(this._imports, importingModule);
    }
}
