/*
 * The MIT License
 *
 * Copyright 2025 Crow281.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * This script generates validation functions for all of the
 * JSON schemas inside of inputPath.
 * If you pass JSON types based on said schema, it will validate them
 * and ensure they match the desired type.
 *
 * HACK: This script currently generates JSDoc by forcibly
 * inserting it into the code generated by ajv.
 * Ideally, it should put it into a separate file
 * so that I don't have to worry about changes to ajv
 * messing up the insertion code.
 */
import { createGeneratedHeaderComment } from "../utils/CreateGeneratedHeaderComment";
import { getLicenseComment } from "../utils/GetLicenseComment";
import { getNPMPackageDependencyType } from "../utils/HasNPMPackage";
import { inputToOutputPath } from "../utils/InputToOutputPath";
import { readJSONGlob } from "../utils/json/ReadJSONGlob";
import { Ajv, ValidateFunction } from "ajv";
import addFormats from "ajv-formats";
import standaloneCode from "ajv/dist/standalone";
import { mkdir, writeFile } from "node:fs/promises";
import { basename, dirname } from "node:path";

/**
 * Path to the JSON schemas we are operating on.
 *
 * Since this script is called at the project root,
 * that is what this path is relative to.
 */
const inputPattern: string = "./src/**/*.schema.json";

/**
 * Root path of the JSON schemas we are operating on.
 * Used to calculate their relative paths.
 *
 * Since this script is called at the project root,
 * that is what this path is relative to.
 */
const inputRoot: string = "./src";

/**
 * File path indicating where we want to output the results to.
 */
export const outputRoot: string = "./src";

/**
 * A comment warning users that this code
 * is using a hack that may need to be resolved some day
 * if either the AJV library changes or someone who
 * knows how to write separated TypeDoc files improves this.
 */
const hackWarningComment: string = `/**
 * HACK: Note that the generation script is basically interfering
 * with how AJV generates code and as such,
 * may need to be updated at some point.
 * 
 * Basically, I am forcibly inserting the validation
 * function's JSDoc.
 * Attempts to use .d.ts files resulted in TypeDoc
 * mistaking it for a separate module.
 * Ideally, if such a thing is possible,
 * someone more familiar with TypeDoc than me should
 * figure out how to separate the JSDoc into a separate
 * file instead of forcibly inserting it into the
 * originally generated module.
 */`;

/**
 * JSDoc typedef defining the interface behind dataCxt,
 * the parameter used to customize the validate function.
 */
const dataValidationCxtTypedef: string = `/**
 * @typedef {Object} DataValidationCxt
 * Interface for an object being used to configure the validation function.
 * @property {string} [instancePath = ""]
 * Path to the specific location of the JSON data being validated.
 * 
 * Is used to to tell error objects the location
 * of the error if validation fails.
 * @property {{ [K in (string | number)]: any }} parentData
 * The parent object of the current data being validated.
 * @property {(string | number)} parentDataProperty
 * Name of the property in parentData being validated.
 * @property {Record<string, any> | any[]} [rootData]
 * The original, unmodified object passed to the validation function.
 * 
 * If the dataCtx parameter passed to the validation function
 * is left empty, this will be set to parameter data.
 */`;

/**
 * JSDoc typedef defining the interface behind ErrorObject,
 * the interface used to indicate whatever went wrong
 * validating an object.
 */
const errorObjectTypedef: string = `/**
 * @typedef {Object} ErrorObject
 * Reports one of the reasons JSON Schema validation failed.
 * 
 * This interface is equivalent to ajv's
 * {@link https://ajv.js.org/api.html#error-objects ErrorObject}.
 * @property {string} keyword
 * Validation keyword.
 * @property {string} instancePath
 * JSON Pointer to the location in the data instance (e.g. "/prop/1/subProp").
 * @property {string} schemaPath
 * JSON Pointer to the location of the failing keyword in the schema.
 * @property {object} params
 * Object with additional information about error.
 * It can be used to generate custom error messages,
 * for example, in conjunction with the ajv-i18n package.
 * 
 * See {@link https://ajv.js.org/api.html#error-parameters error parameters}
 * for more details.
 * @property {string} [propertyName]
 * If error represented a "propertyNames" error,
 * this is set to the propertyName that had the error.
 * @property {string} [message]
 * The error message.
 * @property {any} [schema]
 * The value of the failing keyword in the schema.
 * @property {object} [parentSchema]
 * The object containing the keyword.
 * @property {any} [data]
 * The data validated by the keyword.
 */`;

/**
 * To ensure that the schema interface's
 * type name doesn't collide with anything
 * else, use an alias.
 */
const schemaInterfaceAlias: string = "SchemaInterface";

/**
 * TypeDoc used to document the constant variable
 * that exports the validation function.
 *
 * The "@function" tag is needed to tell TypeDoc
 * to treat this const as the original function.
 */
const exportConstTypeDoc: string = `/**
 * @function
 */`;

//The "use strict" string used by ajv to mark that
//this module should enforce strict parsing and error handling.
const useStrict = '"use strict";';

//Comment used to mark this as a generated file
//and comment telling user where script was created.
const generatedHeader: string = createGeneratedHeaderComment(import.meta.url);

//Fetch license text.
const licenseText: string = await getLicenseComment();

//Combined header source.
const fullHeader: string = `${generatedHeader}
${licenseText}
${hackWarningComment}`;

/**
 * Records any of the generated validators that need
 * the ajv-format NPM package in order to work.
 */
let dependantOnAjvFormatsSchemas: string[] = [];

/**
 * Creates the Ajv object we will be using to create
 * validation functions with.
 * @param schemas
 * JSON schemas the Ajv will be creating validation functions for.
 * @returns
 * Ajv object we will use to create validation functions for a list of schemas.
 */
function createAjv(schemas: object[]): Ajv {
    //Create the ajv instance to process the schemas.
    const ajv = new Ajv({
        //List of schemas to create validation code for.
        schemas: schemas,

        //If false, validation only returns the 1st error it finds,
        //if true, it will return all of them.
        //Since the result is in an array in either case,
        //I've decided to make it true.
        allErrors: true,

        //Activate strict mode.
        //This makes it less flexible in accepting schemas,
        //but also ensures that common mistakes are reported.
        strict: true,

        //Affects whether schema functions referencing other
        //schema copy the validation code into themselves or not.
        //TODO: I considered separating the validation functions
        //into separate modules, but ajv doesn't currently support that,
        //so there is no point in setting inlineRefs to false.
        //If the situation changes, look into it.
        inlineRefs: true,

        //How to generate the code.
        code: {
            //We are generating source files.
            source: true,

            //We are using ESM modules.
            esm: true,

            //Whether AJV will generate the code as a single line
            //or split it across several.
            //Since the code will be recompiled anyways,
            //we may as well make the generated code a bit easier to read.
            lines: true,

            //Improve the code.
            //Usually, 1 pass is enough.
            //2 passes will only improve code slightly
            //if using extremely complicated schemas.
            //But since this won't be used often
            //and a slight delay isn't a huge deal,
            //may as well ensure perfection.
            optimize: 2,
        },
    });

    //Add format support so that strings can be format validated.
    addFormats(ajv);

    return ajv;
}

/**
 *
 * @param moduleName
 * Name of the module to be imported from.
 * @param typeName
 * Name of the type to import.
 */
function createSchemaImportCode(moduleName: string, typeName: string): string {
    //Import code for type of the function and the type being validated.
    //The interface is expected to be in the same folder as the
    //validation function, so use a relative import.
    //Use schemaInterfaceAlias as its alias
    //to ensure its typename doesn't collide with anything.
    const code: string = `//Import the type being validated into JSDoc.
//Use an alias, ${schemaInterfaceAlias}, to make name collision unlikely.
/** @import { type ${typeName} as ${schemaInterfaceAlias} } from "./${moduleName}" */`;

    return code;
}

/**
 *
 * @param typeName
 * Name of the interface representing the JSON schema.
 * @param validationFunctionName
 * Name of the validation function being exported.
 * @returns
 * TypeDoc explaining how the validation function works.
 */
function createValidateFunctionTypeDoc(
    typeName: string,
    validationFunctionName: string,
): string {
    //TypeDoc used to document the validation function.
    const code: string = `/**
 * Checks whether a given value is a valid instance of
 * {@link ${schemaInterfaceAlias} ${typeName}} and matches its
 * {@link https://json-schema.org/ JSON Schema}.
 * @param {any} data
 * Object we want to check to see if it matches {@link ${schemaInterfaceAlias} ${typeName}}.
 * @param {DataValidationCxt} [dataCtx]
 * Used to configure the validation function.
 * @returns {data is ${schemaInterfaceAlias}}
 * true if data is confirmed to be a valid instance of
 * type {@link ${schemaInterfaceAlias} ${typeName}}, false otherwise.
 * 
 * If result is false, you may check property {@link ${validationFunctionName}#errors}
 * for an array of {@link ErrorObject}s to check whatever went wrong.
 * @example
 * This example shows you how you can verify that a
 * value matches type ${typeName}.
 * \`\`\`ts
 * //A function that can only operate on ${typeName}.
 * //Will print it to the console.
 * function printObject(obj: ${typeName}): void {
 *     console.log(obj);
 * }
 * 
 * //Some object we want to validate.
 * const obj: unknown = {
 *     someProperty: 25
 * };
 * 
 * //If this object is a valid instance of Date.
 * if (${validationFunctionName}(obj)) {
 *     //We can use it as the type.
 *     printObject(obj);
 * }
 * \`\`\`
 */`;

    return code;
}

/**
 *
 * @param validationFunctionName
 * Name of the exported validation function.
 * @param validateFunctionImplName
 * Name of the validation function's implementation.
 * @returns
 * Code including TypeDoc explaining the errors property
 * and code initializing it.
 */
function createErrorsCode(
    validationFunctionName: string,
    validateFunctionImplName: string,
): string {
    //TypeDoc used to document the validation function's errors property.
    const code: string = `/**
 * If the validation function returns false,
 * this property will be set to an array of {@link ErrorObject}s,
 * explaining why validation failed.
 * @property
 * @type {null | ErrorObject[]}
 * @example
 * This example shows you how to fetch the resulting
 * {@link ErrorObject}
 * array if something goes wrong during validation.
 * \`\`\`ts
 * //Some object we want to validate.
 * const obj: unknown = {
 *     someProperty: 25
 * };
 * 
 * //If this object is NOT a valid instance of Date.
 * if (!${validationFunctionName}(obj)) {
 *     //Tell user validation failed.
 *     console.log("Obj is NOT an instance of Date");
 * 
 *     //Fetch the list of errors.
 *     //errors is a simplified, standalone equivalent to ErrorObject[]
 *     //from the AJV library.
 *     const errors = ${validationFunctionName}.errors;
 * 
 *     //Iterate the errors.
 *     for (const error of errors) {
 *         //Print the error representing whatever went wrong.
 *         console.log(error);
 *     }
 * }
 * \`\`\`
 */
${validateFunctionImplName}.errors = null;`;

    return code;
}

/**
 * Modifies the string to add insert before the search string.
 * @param original
 * The original string being modified.
 * @param search
 * Search string. Insert will be added
 * immediately before it.
 * @param insert
 * The string to be inserted.
 * @returns
 * The original string with insert added to it.
 */
function insertBefore(
    original: string,
    search: string,
    insert: string,
): string {
    //Locate the search string.
    const index: number = original.indexOf(search);

    //If search does not exist.
    if (index < 0) {
        //Fail.
        throw new Error(
            "Generated code is missing code:\n" +
                search +
                "\n" +
                "This most likely means that the ajv's code generation has " +
                "been changed and that this script will therefore " +
                "need to be updated.",
        );
    }

    //Create the new string,
    //cutting out the beginning, adding the insertion
    //to before search, and adding search and the rest.
    const modified: string =
        original.substring(0, index) + insert + original.substring(index);

    return modified;
}

/**
 * Creates the validation function for the given JSON schema
 * and creates TypeScript code for an ES module.
 * @param ajv
 * AJV object used to generate schema validation code with.
 * @param schema
 * JSON object representing the original schema we are building
 * the validation function for.
 * @param absoluteInputFilePath
 * File path to the schema.
 *
 * Its base name is extracted so that we can figure out
 * the name of the module it is stored to.
 * @returns
 * A promise containing
 * source code for an ES module containing the validation function.
 */
function createValidationCode(
    ajv: Ajv,
    schema: any,
    absoluteInputFilePath: string,
): string {
    //First, gather the variables we need to assemble this code.
    //Get the string used to identify this schema
    const id: string = schema["$id"] as string;

    //Get the TypeScript Type name for the schema interface
    //we are creating a validation function for.
    const typeName: string = schema["title"] as string;

    //Get the basename of the schema so that we
    //know which file to import the schema TypeScript interface from.
    const moduleName = basename(absoluteInputFilePath, ".schema.json");

    //Determine the name of the validation function.
    //For example, the validation function for a schema named "Schema"
    //would have a name of "validateSchema".
    const validationFunctionName: string = `validate${typeName}`;

    //Fetch the validation function for the schema being processed.
    const validateFunction: ValidateFunction = ajv.compile(schema);

    //Fetch the name of the function ajv used to implement
    //the validate function.
    const validateFunctionImplName: string =
        validateFunction.source!.validateName.str;

    //Code used to import the interface used
    //for the schema this function validates.
    const importSchemaTypeCode: string = createSchemaImportCode(
        moduleName,
        typeName,
    );

    //Creates a TypeDoc comment that will explain
    //how the validate function works.
    const validateFunctionTypeDoc: string = createValidateFunctionTypeDoc(
        typeName,
        validationFunctionName,
    );

    //TypeDoc explaining the validation function's errors property.
    const errorsTypeDoc: string = createErrorsCode(
        validationFunctionName,
        validateFunctionImplName,
    );

    //Use ajv to create the validation function module.
    let validationSourceCode: string = standaloneCode(
        ajv,

        //Map the name we want for the validate function to the id of the
        //schema it validates so that AJV knows which schema we want
        //a validate function for and what to rename it to when exporting it.
        {
            [validationFunctionName]: id,
        },
    );

    //Check whether this validation function needs ajv-format.
    if (validationSourceCode.includes(` = require("ajv-formats`)) {
        //Since this validation function needed ajv-format,
        //record that fact for later so that we can
        //remind the user to move ajv-formats
        //to NPM dependencies if necessary.
        dependantOnAjvFormatsSchemas.push(id);
    }

    //If AJV code does NOT start with use strict,
    //that means something has changed and this script needs to be updated.
    if (!validationSourceCode.startsWith(useStrict)) {
        throw new Error(
            'AJV generated code did NOT start with "' +
                useStrict +
                +'", meaning that the library has been changed. ' +
                "Script GenerateSchemaValidators.ts will need to be " +
                "updated accordingly.",
        );
    }

    //Temporarily remove "use strict" from the validation code
    //so that we can insert other stuff right after it.
    validationSourceCode = validationSourceCode.substring(useStrict.length);

    //Insert the typedoc marking the export constant as a function.
    validationSourceCode = insertBefore(
        validationSourceCode,
        `export const ${validationFunctionName}`,
        exportConstTypeDoc + "\n",
    );

    //Insert the typedoc documenting the validation function.
    //It needs to be applied to the original declaration.
    validationSourceCode = insertBefore(
        validationSourceCode,
        `function ${validateFunctionImplName}(`,
        validateFunctionTypeDoc + "\n",
    );

    //Assemble the overall code.
    const code: string = `${fullHeader}
${useStrict}
${importSchemaTypeCode}

${dataValidationCxtTypedef}

${errorObjectTypedef}
${validationSourceCode}
${errorsTypeDoc}
`;

    return code;
}

/**
 * Determines where we should write the validation function
 * for a given schema to.
 * @param schemaAbsoluteFilePath
 * File location relative to base where the original schema file came from.
 *
 * Is used to determine where to write the resulting ES module to.
 * @param schema
 * JSON object representing the original schema we are building
 * the validation function for.
 * @returns
 * File path we should output the validation function
 * for the given schema to.
 */
function createOutputPath(schemaAbsoluteFilePath: string, schema: any): string {
    //Get the TypeScript Typename for the schema.
    const typeName: string = schema["title"] as string;

    //Generate the output path.
    const outputPath: string = inputToOutputPath(
        inputRoot,
        outputRoot,
        schemaAbsoluteFilePath,
        {
            //Converting to the name of the function, "Validate{moduleType}".
            transformBaseName: (oldBaseName: string): string => {
                return `Validate${typeName}`;
            },
            //Converting to a JavaScript file.
            transformFileExtension: (oldFileExtension: string): string => {
                return "js";
            },
        },
    );

    return outputPath;
}

/**
 * Writes the given code to the desired file.
 * @param moduleOutputPath
 * File path we want to write the module to.
 * @param code
 * Code we want to save to the module.
 * @returns
 * A promise that will trigger on operation completion or error.
 */
async function writeModule(
    moduleOutputPath: string,
    code: string,
): Promise<void> {
    //Ensure folder exists.
    await mkdir(dirname(moduleOutputPath), {
        recursive: true,
    });

    //Write the validation function to an es module file.
    await writeFile(moduleOutputPath, code, {
        encoding: "utf-8",
    });
}

/**
 * @returns
 * String indicating which JSON schemas are dependant on ajv-formats.
 */
function createAjvDependantSchemasString(): string {
    //Fetch the list of schemas dependant on ajv-formats
    const dependants: string = dependantOnAjvFormatsSchemas.join("\n");

    //Create the desired string.
    const text: string =
        "The following generated JSON Schema validators " +
        'are dependant on NPM package "ajv-formats":\n\n' +
        dependants;

    return text;
}

/**
 * Checks if the NPM package, ajv-format, is needed as a dependency
 * in order for the validation functions to work and whether
 * user already has it installed as a dependency.
 *
 * If ajv-format is needed and is not saved to
 * the NPM package's dependencies, it will log
 * a warning to user.
 * @returns
 * A promise that will trigger completion when check is done.
 */
async function logAjvFormatWarning(): Promise<void> {
    //If any of the validators are dependant on ajv-format.
    if (dependantOnAjvFormatsSchemas.length > 0) {
        //Check if ajv-format NPM package is installed.
        const dependencyType: string =
            await getNPMPackageDependencyType("ajv-formats");

        //Check ajv-format's installation.
        switch (dependencyType) {
            //If ajv-format is somehow not installed at all,
            //(unlikely as this script should fail
            //completely if that were the case)
            //tell user to install it.
            case "none":
                console.warn(
                    createAjvDependantSchemasString() +
                        "\n\n" +
                        "Install it by using the following console command:\n" +
                        "npm install ajv-formats",
                );
                break;

            //If ajv-format is a devDependency as opposed to a
            //library dependency, tell user to move it.
            case "devDependencies":
                console.warn(
                    createAjvDependantSchemasString() +
                        "\n\n" +
                        "You will need to modify package.json and move " +
                        'ajv-format\'s entry from "devDependencies" to ' +
                        '"dependencies".',
                );
                break;
        }
    }
}

/**
 * Generates and writes the validation code for a single schema.
 * @param ajv
 * Ajv object being used to
 * @param absoluteInputFilePath
 * File path the schema was read from.
 * @param schema
 * Schema we want to write a validation function for.
 * @returns
 * A promise that will trigger on operation completion or error.
 */
async function processSchema(
    ajv: Ajv,
    absoluteInputFilePath: string,
    schema: any,
): Promise<void> {
    //Generate code for this schema.
    const code: string = createValidationCode(
        ajv,
        schema,
        absoluteInputFilePath,
    );

    //Generate file path for this validation function.
    const outputFilePath: string = createOutputPath(
        absoluteInputFilePath,
        schema,
    );

    //Write the module with the validation function.
    await writeModule(outputFilePath, code);
}

//Catch anything that goes wrong.
try {
    //Load the schemas.
    const absoluteFilePathToSchema: Map<string, object> =
        await readJSONGlob(inputPattern);

    //Get a list of all schema objects.
    const schemas: object[] = Array.from(absoluteFilePathToSchema.values());

    //Create Ajv object used to generate validation code.
    const ajv = createAjv(schemas);

    //Array of promises we need to wait on.
    const processPromises: Promise<void>[] = [];

    //Iterate all the schemas.
    for (const [absoluteFilePath, schema] of absoluteFilePathToSchema) {
        //Generate and write code for this schema.
        const processPromise: Promise<void> = processSchema(
            ajv,
            absoluteFilePath,
            schema,
        );

        //Save to array of process promises.
        processPromises.push(processPromise);
    }

    //Wait for all process promises to finish.
    await Promise.all(processPromises);

    //Check if ajv-format is needed and warn the user if so.
    await logAjvFormatWarning();

    //If anything goes wrong, print it.
} catch (error) {
    console.log(error);
}
